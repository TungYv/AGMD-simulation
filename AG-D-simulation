
# coding: utf-8

# This notebook is used for AG-D programming. No membrane.

# # This is the MASTER.
# ## Last checkpoint
# 
# 3. exp_conditionX: PE :
# 4. CalculateH (only for cooling side)has 2 methods.use "A" method!
# 6. heat/mass resistance (absolute) is calculated by delta_T/Q(or permeate). And get somepoint R not average.
# 7. Q verified. Q = Kair/delta_a*(Tha-Tf)+Jv*hg
# 8. GOR(delta hg is evaporation one)\Evaporation Efficiency(the delta_Hg is evaporation one)\All enthalpy is evaporation enthalpy.
# 10. get CalculateEnthalpy of evaporation. least square method.
# 11. Re when method "B" is 150-600(0.1m/s)
# 

# In[1]:

import numpy as np
from matplotlib import pyplot
#from mpl_toolkits.mplot3d import Axes3D
#from matplotlib import cm
get_ipython().magic(u'matplotlib inline')


# In[2]:

# Universal constant
Mv = 18 #(kg/kmol) water 18kg/kmole
R = 8.314*1000 #(J/(kmol K)) kmol, J = Pa * m3
G = 9.80 # (m/s2) gravity
Ptotal = 101325 # (Pa) Total pressure in the model, p = 101325Pa.
## For spacer
SPACER_df = 0.4e-3 # (m) filament diameter
SPACER_hs = 0.8e-3 #(m) thickness of spacer
SPACER_epsilon = .5 # 77.85% spacer porosity from [28]. unsure...

## Each of the following variables is considered as Constant with slight deflection from its present value.
#air gap
Kab = 2.90e-2*3.6 #kJ/(m K hr) = kW/(m K)/3600 thermal conductivity of air mixture in air gap. From "heat transer"--dry air's property.

# For hot side
rho_hotwater = 980. #(kg/m3)
Cp_hot = 4.185 #(kJ/kg/C)

# For falling liquid film
rho_l = 993.5 #(kg/m3) density of falling liquid water. From 'heat transfer'
rho_av = 1.05 # (kg/m3) density of gas mixture in air gap. From both 'heat transfer and thermal dynamics'

# For cold side
rho_coldwater = 993. #(kg/m3), From "heat transer"
Cp_cold = 4.179 # (kJ/kg/C)

## for the membrane
Kair = 2.93e-2*3.6 #kJ/(m K hr) = kW/(m K)/3600 From 'Heat Transfer' dry air property
Km = 0.29*3.6 #kJ/(m K hr) = kW/(m K)/3600 From A.G Fane.2003, at 75C.
epsilon = 0.8 # porosity of membrane
K = epsilon*Kair + (1-epsilon)*Km


# In[3]:

# Compute C
def CalculateC(d,delta_m,tau,T, P, Pv):
    '''
    This func. is no longer used in this no-membrane system.
    Coefficient of Knudsen mass transfer in membrane.
    ------------------------------------------------
    Params
    -----------
    Some are global variables
    d: pore size of membrane(m)
    delta_m: thickness of membrane(m)
    tau: torousity of membrane
    T: Average temperature in membrane.(C)
    P: Total pressure in membrane.(Pa)
    Pv: Vapour pressure in membrane.(Pa)
    
    Return
    --------
    C: membrane mass transfer coefficient.(kg/m2/hr/Pa)
    '''
    #T = T + 273.15 # C to K
    return 7.81*d*epsilon/delta_m/tau*Mv*T**1.072/(5.685*(2*np.pi*R*Mv*T)**.5+4*d*R*(P-Pv))


# In[4]:

# Compute Thm
def ComputeTha(Q, _K_feedwater, _distance, Thb):
    '''
    Using Q(eq.37) compute Thm, then compare it with guess Thm. 
    Params
    --------
    Thb: (C) bulky temperature
    Q: (kJ/(m2 hr)) 
    _K_feedwater: (kJ/(m K hr)) conductivity of feed water in hotside channel.
    _distance: (m) the distance between Thb and Tha. 
    Returns
    ------
    Tha (verified) C 
    '''
    return Thb - Q/_K_feedwater*_distance


# In[5]:

# Dab
def CalculateDab(T, P):
    '''
    Dab is diffusivity between air and water vapour.
    Equation of Dab both used in membrane & air-gap mass transfer. 
    Dab is estimated by T&p, but the dimension is m2/s(or said m2/hr).
    ## Attention! Dab influences Jv profoundly!
    Params
    -------
    T: average temperature in the membrane.(C)
    P: total pressure in the membrane.(Pa)
    
    Returns
    ---------
    Dab: (m2/hr)
    
    '''
    T = T+273.15 # C to K
    #return 1.895e-5*T**2.072/P*3600 # according to Alsaadi
    return 0.302e-2/25*T**1.75/P*3600 # according to Stephan
    #return 3e-5*3600


# In[6]:

# Compute A
def CalculateA(Tavg, P,air_gap_width):
    '''
    Params
    ------
    Tavg: (C) Average temperature inside the membrane.
    P: (Pa) Total pressure inside the membrane.
    Returns
    -------
    A : (kg/hr/m2/Pa) Jv/A = Pma-Pf 
    '''
    Tavg = Tavg + 273.15 # C to K
    Dab = CalculateDab(Tavg,P) #(m2/hr)
    return Dab*Mv/air_gap_width/R/Tavg


# In[7]:

# Water vapour partial pressure
def VaporPressure(T):
    '''
    Params
    ------
    T: (K) Temperature of water vapour(or mixture of water vapour and air).
    Attention! T in K!
    
    Returns
    -------
    P: (Pa) water vapour Partial pressure.
    '''
    b = [-7.8889166,2.5514255,-6.716169,33.239495,-105.38479,174.35319,-148.39348,48.631602]
    Tcrit = 647.25 # K 
    Pcrit = 22.093e6 # Pa
    # sum_b = np.zeros(len(T))
    sum_b = 0.
    for i in range(8):
        sum_b += b[i]*(1-T/Tcrit)**(.5*(i+1)+.5)
    Pd = Pcrit*np.exp(Tcrit/T * sum_b)
    return Pd 


# In[8]:

# miu
def Calculatemiu(T, S):
    '''
    Compute miu, dynamic viscosity of water.
    Parameters
    ---------
    T: (C) water temperature (20<T<180)
    S: (g/kg) salinity (0<S<130)
    Returns
    --------
    miu: (kg/m/s)
    
    '''
    uw = np.exp(-3.7942+604.129/(139.18+T))
    A = 1.474e-3 + 1.5e-6*T - 3.927e-8*T**2
    B = 1.0734e-5 - 8.5e-8*T + 2.23e-10*T**2
    uR = 1 + A*S + B*S**2
    return uw*uR*0.001 


# In[9]:

# Compute specific heat capacity
## not used yet.
def CalculateCp(T,S):
    '''
    Compute heat capacity for water.
    Parameters
    ----------
    T: (C) water temperature (10,180)
    S: (g/kg) Salinity (20,160)
    Returns 
    ----------
    Cp: (kJ/kg/C) at constant pressure.
    
    '''
    A = 4206.8 - 6.6197*S + 1.2288e-2*S**2
    B = -1.1262 + 5.4178e-2*S - 2.2719e-4*S**2 
    C = 1.2026e-2 - 5.3566e-4*S + 1.8906e-6*S**2 
    D = 6.8777e-7 + 1.517e-6*S - 4.4268e-9*S**2 
    return (A+B*T+C*T**2+D*T**3)*0.001 


# In[10]:

# enthalpy for saturated water vapour
def CalculateEnthalpy(T):
    '''
    Calculate enthalpy for saturated water vapour.
    Params
    ------
    T: (C) range of (0.01-200 C) Temperature of water vapour.
    
    Returns
    ----------
    hg: (kJ/kg) Enthalpy in kJ/kg.
    '''
    return 2501.689845 + 1.80692*T + 5.08772e-4*T**2


# In[11]:

def CalculateEnthalpyEvaporation(T):
    '''
    Calculate enthalpy for saturated liquid water. The equation is from Li Site.
    Params
    ------
    T: (C) from 6 - 100 C. temprature of water.
    Returns
    -------
    hg: (kJ/kg)
    '''
    f = np.poly1d([-2.44,2.503*1000])
    return f(T)


# In[12]:

# Compute K of saline water.
def CalculateK_water(T, S):
    '''
    This func is for liquid salt water.
    Params
    -------
    T: (C) 20-180 C Temperature. (20-80)C is acceptable.
    S: (g/kg) 0-160 Salinity.
    
    Returns
    --------
    K: (kJ/(m C hr)) Thermal conductivity.
    
    ---------------------------------------------------------------------
    For K, thermal conductivity of membrane.
    For Kab, thermal conductivity of gas mixture of air and water vapour.
    For Kf, thermal conductivity of condensed water film.
    For Kw, thermal conductivity of cooling plate. 
    
    Is K varies too small in Temperature range?
    Range of temperature: 20-80 C
    20-80C, Kab varies about 16%.
    ## Premise, Kab = 2.9e-2(50C dry air)(W/(m K)), Kw = 40(char-steel)(W/(m K)).
    # Attention! This func. has problem that results is 1000 times larger. I just make results /1000. 
    # in the range of (20-80)C, the error is acceptable. 
    '''
    A = 2e-4
    B = 3.7e-2 
    C = 3e-2 
    Log10_K = np.log10(240+A*S) + 0.434*(2.3-(343.5+B*S)/(T+273.15))*(1-(T+273.15)/(647.3+C*S))**(1./3)
    Kwater = 10**Log10_K*.001 # (W/(m K))
    return Kwater*3.6


# In[13]:

# Compute H 
def CalculateH(width,height,length,k_liquid,rho,miu,V,Pr):
    '''
    This is used for compute H in the hotside or coldside channel.
    # Attention! Choose a method "A" or "B" before using it.
    Params
    ----------
    width,height,length: (m) The scale of the channel.
    k_liquid: (kJ/(m K hr)) thermal conductivity of hot or cold body.
    rho: (kg/m3) use different rho when compute hot and cold water.
    miu: (kg/m/s)dynamic viscosity.
    V: (m/hr) velocity of water.
    Pr = niu/a = miu*Cp/K # varies a lot!
    
    Returns
    ---------
    H: (kJ/(m2 K hr))=(3600*kW/(m2 K)) heat transfer coefficient.
    '''
    _compute_h = "B"
    if _compute_h == "A":
        Ks = 1.904*(SPACER_df/SPACER_hs)**(-.039)*SPACER_epsilon**.75*np.sin((np.pi/4)**.086)
        #Ks = 1.
        dh = 4.*SPACER_epsilon*SPACER_df*SPACER_hs/(2*SPACER_df + 4*(1-SPACER_epsilon)*SPACER_hs)
        #dh = 4.*width*height/(width+height)/2
        Re = rho*dh*V/3600./miu # params of the body.
        Nu = 0.029*Ks*Re**.8*Pr**.33
    elif _compute_h == "B":
        dh = 4.*width*height*2/(width+2*height)/2
        Re = rho*dh*V/3600./miu # params of the body.
        Nu = 1.62*(Re*Pr*dh/length)**.33
    
    calculated_h = Nu*k_liquid/dh
    #print "Ks: %r" %Ks
    #print "Nu: %r" %Nu
    #print "Re: %r" %Re
    #print "dh: %r" %dh
    #print "h: %r " %calculated_h
    
    return calculated_h


# In[14]:

# Compute Pr
def CalculatePr(miu,Cp,lambda_liquid):
    '''
    This func has 2 method to compute Pr, so that Nu can be calculated.
    One is linear function.
    The other is number sections.
    
    Params
    ------ 
    1.
    miu: (kg/m/s)
    cp: (kJ/kg/K)
    lambda_liquid: (kJ/(m K hr)) # attention! kJ/(...hr)
    
    2. T:(C) Temperature of water.
    
    Returns
    ---------
    Pr 
    '''
    
    return miu*Cp/(lambda_liquid/3600)


# In[15]:

# Checking nominal Numbers
def CheckNumber(name):
    '''
    This func is for check: vapour pressure,miu,enthalpy,K_water,heat capacity,Re,Pr,diffusivity.
    '''
    # Input values.
    T_input = np.array([20,30,40,50,60,70,80]) # in C
    # Test values.
    # testvalue = np.empty_like(inputvalue,dtype=np.ndarray)
    print "While the T_inputs are:[20,30,40,50,60,70,80]C."
    print "The test values are:"
    if name == 'VapourPressure':
        Pd = VaporPressure(T_input+273.15)
        print "Pd, partial vapour pressure: %r (Pa)" %Pd # Pd, VaporPressure() is validated.
    elif name == 'miu':
        # pure water S = 0
        S_purewater = np.zeros(len(T_input))
        miu_purewater = Calculatemiu(T_input,S_purewater)
        print "miu, dynamic viscosity of pure water: %r (Pa s)" %miu_purewater # miu, Validated.
        S_salinewater = np.ones(len(T_input))*35
        miu_salinewater = Calculatemiu(T_input,S_salinewater)
        print "miu, dynamic viscosity of saline water: %r (Pa s)" %miu_salinewater # miu, Validated.
    elif name == 'enthalpy':
        enthalpy = CalculateEnthalpy(T_input)
        print "Enthalpy of water vapour: %r (kJ/kg)" %enthalpy # Enthalpy validated.
    elif name == 'K_water':
        K_water = CalculateK_water(T_input,0)
        print "K_water for pure water: %r (kJ/(m C hr))" %K_water # Validated!
    elif name == 'Pr':
        # for pure water:
        S_purewater = np.zeros(len(T_input))
        miu = Calculatemiu(T_input,S_purewater)
        #Cp = 4.19 #kJ/kg/C
        #K = .63 #W/m/C
        K_hotwater = CalculateK_water(T_input,S_purewater)
        Pr = CalculatePr(miu,Cp_hot,K_hotwater)
        print "Pr for pure hot water is: %r" %Pr # Pr is Validated.
    elif name == 'diffusivity':
        P = 101325 # Pa
        T = np.array([0.,25.,40.,60.]) # C
        D = CalculateDab(T,P) # m2/hr
        D = D/3600. # m2/s
        print "T at %r C" %T
        print "Diffusivity between water vapour and air: %r*10^(-5)" %(D*10**5) # NOT! but in the range(20-80)is ok.
    elif name == 'H':
        V = 1.5*3600 #(m/hr) average velocity of water
        miu = Calculatemiu(40.,0)
        Pr = 4.102 #CalculatePr(miu_hot,Cp_hot,K_hotwater)
        rho = 991. #(kg/m3)
        k_l = 0.638*3.6 #(W/(m K))
        width = 1.
        height = 1.
        H = CalculateH(width,height,k_l,rho,miu,V,Pr)
        print "H, for Heat Transfer a example: %r (kJ/(m2 K hr))= %r (W/(m2 K))" %(H,H/3.6) # Validated, but whether dh is right?
        print "miu: %r(Pa s)" %miu
    else:
        raise NameError("My Error! No such function. Please input a valid string!")


# In[16]:

CheckNumber('K_water')


# In[17]:

# Computation for Jv
def ComputationForJv(Tha,Tf,air_gap_width):
    '''
    For neat code in the Loop.
    '''
    Tave = .5*(Tha+Tf)
    #Pv = VaporPressure(Tave+273.15) # water vapour pressure inside membrane
    #C = CalculateC(d,delta_m,tau,Tave,Ptotal,Pv)
    A = CalculateA(Tave,Ptotal,air_gap_width)
    Pha = VaporPressure(Tha+273.15)
    Pf = VaporPressure(Tf+273.15)
    return A,Pha,Pf


# In[18]:

# Computation for Q
def ComputationForQ(width,height,mh,Tha,Tf,Thb,S_hot,K_hotwater):
    '''
    This func. is no longer necessary, for in feed water channel, no Hh needed.
    '''
    Vh = mh/rho_hotwater/(width*height)#(m/hr) average velocity of water
    hg = CalculateEnthalpy(.5*(Tha+Tf))
    miu_hot = Calculatemiu(Thb,S_hot)
    Pr_hot = CalculatePr(miu_hot,Cp_hot,K_hotwater)
    Hh = CalculateH(width,height,K_hotwater,rho_hotwater,miu_hot,Vh,Pr_hot)
    return hg,Hh


# In[19]:

# Computation for Tf
def ComputationForTf(width,height,length,mc,Sc,Tcb,Tf):
    '''For neat code.'''
    Vc = mc/rho_coldwater/(width*height)#(m/hr) average velocity of water
    miu_cold = Calculatemiu(Tcb,Sc)
    K_coldwater = CalculateK_water(Tcb,Sc)
    K_fallingwater = CalculateK_water(Tf,0)
    Pr_cold = CalculatePr(miu_cold,Cp_cold,K_coldwater)
    Hc = CalculateH(width,height,length,K_coldwater,rho_coldwater,miu_cold,Vc,Pr_cold)
    return Hc,K_fallingwater


# In[20]:

# Checking
def Checking(Jv,delta_f,Q,Tf,temp):
    '''
    This func is only for checking inter-loop results by print them.
    
    '''
    print 
    print "This is checking function:"
    print 'Jv, water vapor flux: %r(kg/m2/hr)' %Jv
    print "delta_f: %r (m)" %delta_f 
    print "Q, transport energy: %r(kJ/m2/hr)" %Q 
    print "Tf,temperature of falling water flim: %r(C)" %Tf 
    print "The criterion value is: %r " %temp


# In[21]:

def resistance_mass_transfer(T1,T2,Thb,Tcb,permeat):
    '''
    This func is used to compute mass transfer resistance in every grid horizontally.
    -------
    Params
    ------
    T1,T2: (C) The temperature at two points for calculate pressure, the former is higher than the latter, P1=f(T1),P2=f(T2).
    Thb, Tcb: (C) The max and the minimize temperature(in flow water) for calculate pressure, Phb=f(Thb) and Pcb=f(Tcb).
    permeat: (kg/m2/hr) the permeating water flux.
    
    Returns
    ------
    resistance: The mass transfer resistance in each domain.
    relative_resistance: The relative one. relative_resistance=resistance/Sigma(resistance)
    '''
    delta_P = VaporPressure(T1+273.15) - VaporPressure(T2+273.15)
    delta_Ptotal = VaporPressure(Thb+273.15) - VaporPressure(Tcb+273.15)
    resistance = delta_P/permeat
    relative_resistance = delta_P/delta_Ptotal
    return resistance,relative_resistance


# In[22]:

def resistance_heat_transfer(T1,T2,Thb,Tcb,heat_transfer):
    '''
    This func is used to compute heat transfer resistance in every grid horizontally.
    -------
    Params
    ------
    T1,T2: (C) The former is higher than the latter.
    Thb, Tcb: (C) The max and the minimize temperature(in flow water).
    heat_transfer: (kJ/m2/hr) the permeating water flux.
    
    Returns
    ------
    resistance: The heat transfer resistance in each domain.
    relative_resistance: The relative one. relative_resistance=resistance/Sigma(resistance)
    '''
    delta_T = T1 - T2
    delta_Ttotal = Thb - Tcb
    resistance = delta_T/heat_transfer
    relative_resistance = delta_T/delta_Ttotal
    return resistance,relative_resistance


# In[23]:

class AG_D:
    '''Using for computing AGMD process. Single input and equal output.'''
    def __init__(self, _L,_W,_hfc,_hcc,_delta_a,_delta_c,_Kw,_mhi,_mci,_thi,_tci,_shi,_sc):
        '''
        Setting up the module features and operation condition.
        Params
        -------
        _L: (m) Length scale of the module
        _W: (m) Width of the module
        _hfc: (m) height of the feed channel
        _hcc: (m) height of the cooling channel
        _delta_a: (m) distance of air gap
        _delta_c: (m) thickness of membrane
        _Kw: (kJ/m2 K hr) thermal conductivity of cooling plate
        _mhi: (kg/hr) mass of hot water inlet
        _mci: (kg/hr) mass of cooling water inlet(never change)
        _thi: (C) temperature of hot water inlet
        _tci: (C) temperature of cooling water inlet
        _shi: (g/kg) salinity of hot water inlet
        _sc: (g/kg) salinity of cooling water(never change)
        '''
        # Module characters.
        self.length_vertical_effective = _L
        self.width_effective = _W
        self.height_feed_channel = _hfc
        self.height_cooling_channel = _hcc
        self.delta_a = _delta_a
        #self.thermal_conductivity_air = _thermal_conductivity_air # It is a Global params.
        self.delta_c = _delta_c
        self.Kw = _Kw
        
        # Operation conditions.
        self.mass_hot_inlet = _mhi
        self.mass_cold_inlet = _mci
        self.temperature_hot_inlet = _thi
        self.temperature_cold_inlet = _tci
        self.salinity_hot_inlet = _shi
        self.salinity_cold = _sc
        print "Next step: Setup mesh please."
        
    def get_velocity(self):
        '''For compute velocity from mass flow.'''
        self.hot_velocity = self.mass_hot_inlet/self.height_feed_channel/self.width_effective                            /rho_hotwater/3600
        self.cold_velocity = self.mass_cold_inlet/self.height_cooling_channel/self.width_effective                            /rho_coldwater/3600
        
    def get_mesh_setup(self, Nx):
        '''
        Mesh setup and initializes Numpy array.
        Params
        ------
        Nx, numerber of grids
        
        Generates
        -----------
        x: 1-D array of Nx floats, stores dimension info.
        Thb,Tha,Tf,Tfp,Tpc,Tcb: 1-D array of Nx floats, stores temperature info.
        mh,S_hot: 1-D array of Nx floats, stores feed water info.
        '''
        
        # Nx # Mesh grid number. value from input
        self.x = np.linspace(0,self.length_vertical_effective,Nx)
        self.dx = self.length_vertical_effective/(Nx-1)
        
        self.Thb = np.ones(Nx)*self.temperature_hot_inlet # the body temperature of hot water inlet.
        self.Tcb = np.ones(Nx)*self.temperature_cold_inlet # the body temperature of cooling water inlet.
        self.Tf = np.ones(Nx) # The T of condensing film interface.
        self.Tha = np.ones(Nx) # The T of the interface of hotfeed and airgap.
        #self.Thm = np.ones(Nx) # The T of the interface of hotfeed and membrane.
        #self.Tma = np.ones(Nx) # The T of the surface of membrane facing the air channel.
        self.Tfp = np.ones(Nx) # The T of film water in contact with cooling plate.
        self.Tpc = np.ones(Nx) # The T of the wall in cooling channel.
        self.mh = np.ones(Nx)*self.mass_hot_inlet # mass flow of hot water at every grid.
        self.S_hot = np.ones(Nx)*self.salinity_hot_inlet # salinity of hot water.
        ## store output values wanted to show.
        self.Jv_flux_condensed_water_along = np.zeros(Nx) # condensed water flux along the membrane
        self.Q_heattransfer_along = np.zeros(Nx) # heat transfer along the membrane
        self.delta_f_condensed_water_along = np.zeros(Nx) #delta_f along the membrane
        print "Mesh setup done."
        
        
    def get_co_current(self, Nx):
        '''To calculate co-current regime.
        Params
        ------
        Nx: grids of the mesh.
        
        Generates
        ---------
        Jv_flux_condensed_water_along: kg/m2/hr. 1-D array, with Nx floats.
        Q_heattransfer_along: kJ/m2/hr. 1-D array, with Nx floats.
        delta_f_condensed_water_along: m. Water film along the cooling plate. 1-D array, with Nx floats.
        '''
        print "This is co-current flow pattern."
        print "Hot water inlet at %d C" %self.temperature_hot_inlet
        print "Cooling water inlet at %d C" %self.temperature_cold_inlet
        print "Hot feed at %.2f LPM" %(self.mass_hot_inlet/60.)
        print "Cooling mass inlet: %.2f LPM"%(self.mass_cold_inlet/60)
        print "Air gap distance: %.2f mm"%(self.delta_a*1000)
        print 

        for i in range(Nx):
            print "Step %r of %r." %(i,Nx)
            error_Tf = 10.
            self.Tf[i] = .5*(self.Thb[i]+self.Tcb[i]) # supposed
            Tf_step = 0
            while error_Tf > 1e-6 and Tf_step <= 20:
                Tf_step += 1
                error_Tha = 10.
                self.Tha[i] = .5*(self.Thb[i]+self.Tf[i]) # supposed
                # Q_premise = 20.0e3 #(kJ/m2/hr) supposed
                error_Tha_threshold = 1e-6 # threshold for error(while)
                Tha_step = 0
                while error_Tha > error_Tha_threshold and Tha_step <= 30 :
                    Tha_step += 1
                    #Tave = .5*(self.Thm[i]+self.Tma[i]) # average temperature inside membrane
                    A,Pha,Pf = ComputationForJv(self.Tha[i],self.Tf[i],self.delta_a)
                    Jv = A*(Pha-Pf) #Compute A,Pf,Pmh

                    K_feedwater = CalculateK_water(self.Thb[i],self.S_hot[i])
                    hg = CalculateEnthalpyEvaporation(.5*(self.Tha[i]+self.Tf[i]))
                    Q = (self.Thb[i] - self.Tf[i] + Jv*hg*(self.delta_a/Kab))/(self.delta_a/Kab) 
                    #Compute hg,K_water. delta_a are Const. T depends on grid.

                    #Tha_temp = ComputeTha(Q,K_feedwater,.5*self.height_feed_channel,self.Thb[i])
                    Tha_temp = self.Thb[i]
                    error_Tha = abs(Tha_temp - self.Tha[i])/Tha_temp
                    self.Tha[i] = Tha_temp
                    #Checking
                    #Checking(Jv,"no deltaf",Q,self.Tf[i],self.Tha[i])

                #print 
                #print "## 1st Loop ends here. Use kepboard to interrupt."
                #print 'Difference of Thm between steps is: %5.5f' %error_Thm
                #print 
                #raw_input()
                miu_f = Calculatemiu(self.Tf[i],0)
                delta_f = (3.*Jv/3600*miu_f/(rho_l*(rho_l - rho_av)*G)*self.x[i])**(1./3) 
                #rho_av,rho_l,g is Const. Compute miu. x depends on grid.

                Hc,Kf = ComputationForTf(self.width_effective,self.height_cooling_channel,self.length_vertical_effective/(Nx-1),                                         self.mass_cold_inlet,self.salinity_cold,self.Tcb[i],self.Tf[i])
                Tf_temp = Q*(delta_f/Kf+self.delta_c/self.Kw+1./Hc) + self.Tcb[i] 
                # Kw,delta_c/f are Const. Hc,Kf needs computed. T depends on grid.

                error_Tf = abs(Tf_temp - self.Tf[i])/Tf_temp
                self.Tf[i] = Tf_temp
                #self.Tma[i] = (Kab/self.delta_a*self.Tf[i] + K/self.delta_m*self.Thm[i])/(Kab/self.delta_a + K/self.delta_m)
                # Checking 
                #Checking(Jv,delta_f,Q,self.Tf[i],"Tf[i]")
                #print "Hc is: %r kJ/(m2 K hr)" %Hc

            #print 
            #print "## 2nd Loop ends here. Use keyboard to interrupt."
            #print 'Difference of Thm between steps is: %r' %error_Thm
            #print 'Difference of Tf between steps is: %r' %error_Tf
            #print 
            # raw_input()
            # Next state
            if i < (Nx-1):
                self.mh[i+1] = self.mh[i]-Jv*self.dx*self.width_effective
                self.S_hot[i+1] = self.mh[i]*self.S_hot[i]/self.mh[i+1]
                self.Thb[i+1] = (self.mh[i]*Cp_hot*self.Thb[i] - Q*self.dx*self.width_effective)/Cp_hot/self.mh[i+1]
                self.Tcb[i+1] = self.Tcb[i] + Q*self.dx*self.width_effective/(Cp_cold*self.mass_cold_inlet)
            else:
                print "The end. i = %d."%i

            # Outputs Jv,Q,delta_f arrays
            self.Jv_flux_condensed_water_along[i] = Jv # condensed water flux along the membrane
            self.Q_heattransfer_along[i] = Q # heat transfer along the membrane
            self.delta_f_condensed_water_along[i] = delta_f #delta_f along the membrane

        #Checking output
        print "Results are: "
        #print "Jv along the length: %r (kg/(m2 hr))" %self.Jv_flux_condensed_water_along
        #print "Q along the length: %r (kJ/m2/hr)" %Q_N
        #print "delta_f along the length: %r (m)" %delta_fN
        self.Jv_flux_average = (sum(self.Jv_flux_condensed_water_along)-                                                       self.Jv_flux_condensed_water_along[-1])*self.dx/self.length_vertical_effective
        print "Average permeate water: %r kg/hr/m2" %self.Jv_flux_average
        # shape(Jv_N)=number(dx)+1
        print "Average of sum(flux)/Nx: %.2f " %(sum(self.Jv_flux_condensed_water_along)/Nx)
        
    def get_counter_current(self,Nx):
        '''
        This func is to calculate counter-current regime.
        Params
        -------
        Nx: grids of the mesh.
        
        Generates
        ---------
        Jv_flux_condensed_water_along: kg/m2/hr. 1-D array, with Nx floats.
        Q_heattransfer_along: kJ/m2/hr. 1-D array, with Nx floats.
        delta_f_condensed_water_along: m. Water film along the cooling plate. 1-D array, with Nx floats.
        '''
        print "This is counter-current flow pattern."
        print "Hot water inlet at: %d C" %self.temperature_hot_inlet
        print "Hot feed mass inlet %.2f LPM" %(self.mass_hot_inlet/60.)
        print "Cooling water inlet at: %d C" %self.temperature_cold_inlet
        print "Cooling mass inlet %.2f LPM"%(self.mass_cold_inlet/60)
        print "Air gap distance: %.2f mm"%(self.delta_a*1000)
        print 
        
        learnRate = 2.
        error_Tcb = 10.
        error_i = 0. # alpha/(error_i+1) to make alpha decrease every step.
        self.warning_flag = False #detecting divergence
        self.Tcb[0] = .3*(self.Thb[0]+self.Tcb[-1]) # supposed
        while error_Tcb > 1e-6 and error_i <= 30:
            if error_i == 30:
                self.warning_flag = True
            for i in range(Nx):
                #print "Step %r of %r." %(i,Nx)
                error_Tf = 10.
                self.Tf[i] = .5*(self.Thb[i]+self.Tcb[i]) # supposed
                Tf_step = 0
                while error_Tf > 1e-6 and Tf_step <= 30:
                    if Tf_step == 30:
                        self.warning_flag = True
                    Tf_step += 1
                    error_Tha = 10.
                    self.Tha[i] = .5*(self.Thb[i]+self.Tf[i]) # supposed
                    # Q_premise = 20.0e3 #(kJ/m2/hr) supposed
                    error_Tha_threshold = 1e-6 # threshold for error(while)
                    Tha_step = 0
                    while error_Tha > error_Tha_threshold and Tha_step <= 30 :
                        Tha_step += 1
                        #Tave = .5*(self.Thm[i]+self.Tma[i]) # average temperature inside membrane
                        A,Pha,Pf = ComputationForJv(self.Tha[i],self.Tf[i],self.delta_a)
                        Jv = A*(Pha-Pf) #Compute A,Pf,Pmh

                        K_feedwater = CalculateK_water(self.Thb[i],self.S_hot[i])
                        hg = CalculateEnthalpyEvaporation(.5*(self.Tha[i]+self.Tf[i]))
                        Q = (self.Thb[i] - self.Tf[i] + Jv*hg*(self.delta_a/Kab))/(self.delta_a/Kab) 
                        #Compute hg,K_water. delta_a are Const. T depends on grid.

                        #Tha_temp = ComputeTha(Q,K_feedwater,.5*self.height_feed_channel,self.Thb[i])
                        Tha_temp = self.Thb[i]
                        error_Tha = abs(Tha_temp - self.Tha[i])/Tha_temp
                        self.Tha[i] = Tha_temp
                        #Checking
                        #Checking(Jv,"no deltaf",Q,self.Tf[i],self.Tha[i])

                    #print 
                    #print "## 1st Loop ends here. Use kepboard to interrupt."
                    #print 'Difference of Thm between steps is: %5.5f' %error_Thm
                    #print 
                    #raw_input()
                    miu_f = Calculatemiu(self.Tf[i],0)
                    delta_f = (3.*Jv/3600*miu_f/(rho_l*(rho_l - rho_av)*G)*self.x[i])**(1./3) 
                    #rho_av,rho_l,g is Const. Compute miu. x depends on grid.

                    Hc,Kf = ComputationForTf(self.width_effective,self.height_cooling_channel,self.length_vertical_effective/(Nx-1),                                             self.mass_cold_inlet,self.salinity_cold,self.Tcb[i],self.Tf[i])
                    Tf_temp = Q*(delta_f/Kf+self.delta_c/self.Kw+1./Hc) + self.Tcb[i] 
                    # Kw,delta_c/f are Const. Hc,Kf needs computed. T depends on grid.
                    self.Tfp[i] = self.Tf[i] - Q*delta_f/Kf
                    self.Tpc[i] = self.Tfp[i] - Q*self.delta_c/self.Kw

                    error_Tf = abs(Tf_temp - self.Tf[i])/Tf_temp
                    self.Tf[i] = Tf_temp
                    #self.Tma[i] = (Kab/self.delta_a*self.Tf[i] + K/self.delta_m*self.Thm[i])/(Kab/self.delta_a + K/self.delta_m)
                    # Checking 
                    #Checking(Jv,delta_f,Q,self.Tf[i],"Tf[i]")
                    #print "Hc is: %r kJ/(m2 K hr)" %Hc

                #print 
                #print "## 2nd Loop ends here. Use keyboard to interrupt."
                #print 'Difference of Thm between steps is: %r' %error_Thm
                #print 'Difference of Tf between steps is: %r' %error_Tf
                #print 
                # raw_input()
                # Next state
                if i < (Nx-1):
                    self.mh[i+1] = self.mh[i]-Jv*self.dx*self.width_effective
                    self.S_hot[i+1] = self.mh[i]*self.S_hot[i]/self.mh[i+1]
                    # compute Cph,Cpc separately
                    self.Thb[i+1] = (self.mh[i]*Cp_hot*self.Thb[i] - Q*self.dx*self.width_effective)/Cp_hot/self.mh[i+1]
                    self.Tcb[i+1] = self.Tcb[i] - Q*self.dx*self.width_effective/(Cp_cold*self.mass_cold_inlet)
                else:
                    #print "The end. i = %d."%i
                    pass


                # Outputs Jv,Q,delta_f arrays
                self.Jv_flux_condensed_water_along[i] = Jv # condensed water flux along the membrane
                self.Q_heattransfer_along[i] = Q # heat transfer along the membrane
                self.delta_f_condensed_water_along[i] = delta_f #delta_f along the membrane

            print "Tcb[-1]: %.4f C" %self.Tcb[-1]
            if self.Tcb[-1] < 0.: 
                self.Tcb[-1] = 0.
            elif self.Tcb[-1] > self.temperature_hot_inlet: 
                self.Tcb[-1] = self.temperature_hot_inlet
            temp_move = self.Tcb[-1] - self.temperature_cold_inlet
            error_Tcb = abs(temp_move)/self.temperature_cold_inlet
            alpha = 1./(.5*error_i+1)*learnRate
            error_i += 1 
            self.Tcb[0] = self.Tcb[0] - temp_move
        #checking output
        if self.warning_flag: print "Warning! Divergence detected! Iteration step reaches maximum, and results maybe not precise."
        print '[Convergency Criterion]'+'\n  The difference of Temperature(cold outlet) between steps is: %r' %error_Tcb
        print "  The difference of Temperature of inter-loop(Taf) between steps is: %r" %error_Tf
        print "Results are: "
        #print "Jv along the length: %r (kg/(m2 hr))" %self.Jv_flux_condensed_water_along
        #print "Q along the length: %r (kJ/m2/hr)" %Q_N
        #print "delta_f along the length: %r (m)" %delta_fN
        self.Jv_flux_average = (sum(self.Jv_flux_condensed_water_along)-self.Jv_flux_condensed_water_along[-1])*self.dx/self.length_vertical_effective
        print "Average permeate water: %r kg/hr/m2" %self.Jv_flux_average


# In[24]:

def plot_along_membrane(plot_title,plot_ylabel,x_values,y_values,y_limits):
    '''
    Pyplot to show T, mh, Jv, delta_f along the membrane.
    Params
    ------
    plot_title,plot_ylabel: strings, to describe Title and Y-Label of the fig plotted.
    x_values,y_values: 1-D array of floats.
    y_limits: 1-D array with 2 elements which defines the lower/upper boundary of the plot y-value
                i.e. y_limits = [lowerbound, upperbound]
                if no concerns for boundary, input y_limits = "no boundary" instead.
    '''
    Font  = {'family':'Tahoma','size':10}
    pyplot.figure(figsize=(10,5))
    pyplot.title(plot_title);
    pyplot.xlabel('x(m)',fontdict=Font);
    pyplot.ylabel(plot_ylabel,fontdict=Font);
    if type(y_limits) == str:
        print "No specific restrict boundary."
    elif type(y_limits) == list:
        y_max = y_limits[1]
        y_min = y_limits[0]
        pyplot.ylim(y_min,y_max)
    else : 
        raise NameError("My Error. y_limits input is wrong.")
    pyplot.scatter(x_values,y_values,marker='^')
    pyplot.plot(x_values,y_values,color='#003366',ls='-')


# In[25]:

def plot_flux_vs_X(plot_title,plot_ylabel,y_labels,plot_xlabel,x_values,y_values,x_limits,y_limits):
    '''
    Pyplot to show varying Jv(flux of condensed water on the cooling plate) depends on other parameters(velocity,airgap,length).
    ------
    Params
    ------
    plot_title,plot_ylabel,plot_xlabel: strings, to describe Title and Y-Label of the fig plotted.
    y_labels: name strings of plot y_values.
    x_values: 1-D array of floats.
    y_values: n-D array of floats.
    y_limits,x_limits: 1-D array with 2 elements which defines the lower/upper boundary of the plot y-value
                i.e. y_limits = [lowerbound, upperbound]
                if no concerns for boundary, input y_limits = "no boundary" instead.
    '''
    Font  = {'family':'Tahoma','size':10}
    pyplot.figure(figsize=(10,5))
    pyplot.title(plot_title);
    pyplot.xlabel(plot_xlabel,fontdict=Font);
    pyplot.ylabel(plot_ylabel,fontdict=Font);
    if type(y_limits) == str and type(x_limits)==str:
        print "No specific restrict boundary."
    elif type(y_limits) == list and type(x_limits)==list:
        y_max = y_limits[1]
        y_min = y_limits[0]
        x_max = x_limits[1]
        x_min = x_limits[0]
        pyplot.xlim(x_min,x_max)
        pyplot.ylim(y_min,y_max)
    else : 
        raise NameError("My Error. x/y_limits input is wrong.")
    n = len(y_values)
    line_traits = ['-',':','--','-*','-s','-o','-<']
    line_traits_n = line_traits[:n]
    try:
        pyplot.scatter(x_values,y_values,marker='^')
        pyplot.plot(x_values,y_values,color='#003366',ls='-')
    except:
        for i,line_trait in enumerate(line_traits_n):
            #pyplot.scatter(x_values,y_values[i],marker='^')
            pyplot.plot(x_values,y_values[i],line_trait)
        pyplot.legend(y_labels)


# In[26]:

def plot_flux_vs_X_mass(plot_title,plot_ylabel,y_labels,plot_xlabel,x_values,y_values,x_limits,y_limits):
    '''
    Pyplot to show varying Jv(flux of condensed water on the cooling plate) depends on other parameters(velocity,airgap,length).
    ------
    Params
    ------
    plot_title,plot_ylabel,plot_xlabel: strings, to describe Title and Y-Label of the fig plotted.
    y_labels: name strings of plot y_values.
    x_values: 1-D array of floats.
    y_values: n-D array of floats.
    y_limits,x_limits: 1-D array with 2 elements which defines the lower/upper boundary of the plot y-value
                i.e. y_limits = [lowerbound, upperbound]
                if no concerns for boundary, input y_limits = "no boundary" instead.
    '''
    Font  = {'family':'Tahoma','size':10}
    pyplot.figure(figsize=(10,5))
    pyplot.title(plot_title);
    pyplot.xlabel(plot_xlabel,fontdict=Font);
    pyplot.ylabel(plot_ylabel,fontdict=Font);
    if type(y_limits) == str and type(x_limits)==str:
        print "No specific restrict boundary."
    elif type(y_limits) == list and type(x_limits)==list:
        y_max = y_limits[1]
        y_min = y_limits[0]
        x_max = x_limits[1]
        x_min = x_limits[0]
        pyplot.xlim(x_min,x_max)
        pyplot.ylim(y_min,y_max)
    else : 
        raise NameError("My Error. x/y_limits input is wrong.")
    n = len(y_values)
    line_traits = ['-',':','--','-*','-s','-o','-<']
    line_traits_n = line_traits[:n]
    try:
        pyplot.scatter(x_values,y_values,marker='^')
        pyplot.plot(x_values,y_values,color='#003366',ls='-')
    except:
        for i,line_trait in enumerate(line_traits_n):
            #pyplot.scatter(x_values,y_values[i],marker='^')
            pyplot.plot(x_values,y_values[i],line_trait)
        pyplot.legend(y_labels,bbox_to_anchor=(0.2,1),prop={'size':10})


# In[27]:

def plot_muliti_along(plot_title,_list_labels,                     x_values,_list_values,y_label,y_limits):
    '''
    Pyplot to show multi-various along the membrane. The 3rd([2]) position is for Tf or Rfp etc..
    ---------------
    Params
    ------
    plot_title,plot_ylabel_N: strings, to describe Title and Y-Label of the fig plotted.
    x_values: x along the membrane. 1-D array of floats.
    y_values_N: (C) Temperature along the membrane. 1-D array of floats.
    y_label: a string for y axis.
    y_limits: 1-D array with 2 elements which defines the lower/upper boundary of the plot y-value
                i.e. y_limits = [lowerbound, upperbound]
                if no concerns for boundary, input y_limits = "no boundary" instead.
    '''
    Font  = {'family':'Tahoma','size':10}
    pyplot.figure(figsize=(10,5))
    pyplot.title(plot_title);
    pyplot.xlabel('x (m)',fontdict=Font);
    pyplot.ylabel(y_label,fontdict=Font);
    if type(y_limits) == str:
        print "No specific restrict boundary."
    elif type(y_limits) == list:
        y_max = y_limits[1]
        y_min = y_limits[0]
        pyplot.ylim(y_min,y_max)
    else : 
        raise NameError("MyError! y_limits input is wrong.")
    #pyplot.scatter(x_values,y_values,marker='^')
    n_arrays = len(_list_labels)
    line_traits = ['-',':','--','-*','-s','-o','-<']
    line_traits_n = line_traits[:n_arrays]
    for i_array,line_trait in enumerate(line_traits_n):
        #if i_array == 2: pyplot.plot(x_values,_list_values[i_array], ls='o')
        #else: plot()
        pyplot.plot(x_values,_list_values[i_array],line_trait)
    #pyplot.plot(x_values,y_values1,color='#003366')
    #pyplot.plot(x_values,y_values2)
    #pyplot.plot(x_values,y_values3,ls='-.')
    #pyplot.scatter(x_values,y_values3)
    #pyplot.plot(x_values,y_values4)
    #pyplot.plot(x_values,y_values5)
    #pyplot.plot(x_values,y_values6)
    #pyplot.legend((plot_ylabel1,plot_ylabel2,plot_ylabel3,plot_ylabel4,plot_ylabel5,plot_ylabel6))
    pyplot.legend(_list_labels)


# In[28]:

# For our Graduation experiment condition
def exp_conditionX(_vhi,_vci,_airgap,_length,Nx):
    '''
    Only for neat code when testing Xu's condition.
    Since the model is symmetric on both sides(axes of hot and cooling channels), the hot channel is 4./2 = 2mm, cooling is 3./2=1.5mm.
    -------------------------------------------
    Params
    -------
    _vhi,_vci: (m/s) The velocity of hot/cooling saline water.
    _airgap: (m) The distance of airgap.
    _length: (m) The length of model.
    
    Generates
    ------
    Test instance of counter current.
    '''
    velocity_feeding_inlet = _vhi # (m/s) The velocity of feeding saline water.
    velocity_cooling_inlet = _vci # (m/s) The velocity of cooling water.
    width_of_model = 1.
    height_of_hotchannel = 4e-3/2 #(m) The height of hot channel
    height_of_coolingchannel = 3e-3/2 # (m) The height of cooling channel
    mass_feeding_inlet = rho_hotwater*velocity_feeding_inlet*width_of_model*height_of_hotchannel*3600 # (kg/hr)
    mass_cooling_inlet = rho_coldwater*velocity_cooling_inlet*width_of_model*height_of_coolingchannel*3600 # (kg/hr)
    test_nomembrane = AG_D(_L=_length,_W=width_of_model,_hfc=height_of_hotchannel,_hcc=height_of_coolingchannel,                           _delta_a=_airgap,_delta_c=.1e-3,_Kw=0.4*3.6,                        _mhi=mass_feeding_inlet,_mci=mass_cooling_inlet,_thi=80.,_tci=20,_shi=42.,_sc=42.);
    test_nomembrane.get_mesh_setup(Nx);
    test_nomembrane.get_counter_current(Nx);
    return test_nomembrane


# In[29]:

def exp_conditionB(_mhiB,_mciB,_thiB,_tciB,_airgap,Nx):
    '''
    For neat code when testing Banat condition.
    Since the model is symmetric on both sides(axes of hot and cooling channels), the hot channel is 4./2 = 2mm, cooling is 4./2=2mm.
    -------------------------------------------
    Params
    -------
    _mhiB,_mciB: (L/min) The mass flow of hot/cooling water.
    _thiB,_tciB: (C) the temperature of inlet water
    _airgap: (m) The distance of airgap.
    
    Generates
    ------
    Test instance of counter current.
    '''
    length_of_model = 1. # m
    width_of_model = 1. # m
    height_of_hotchannel = 4e-3/2 #(m) The height of hot channel
    height_of_coolingchannel = 3e-3/2 # (m) The height of cooling channel
    test_nomembrane = AG_D(_L=length_of_model,_W=width_of_model,_hfc=height_of_hotchannel,_hcc=height_of_coolingchannel,                           _delta_a=_airgap,_delta_c=0.1e-3,_Kw=0.4*3.6,                        _mhi=_mhiB*60,_mci=_mciB*60,_thi=_thiB,_tci=_tciB,_shi=42.,_sc=42.);
    test_nomembrane.get_mesh_setup(Nx);
    test_nomembrane.get_counter_current(Nx);
    return test_nomembrane


# In[30]:

def compute_mass_resistance(_instance):
    
    T_test_list = np.array((_instance.Tha,_instance.Tf,_instance.Tfp,_instance.Tpc,_instance.Tcb))
    #R_heat_list = resistance_heat_transfer(T_test_list[:-1],T_test_list[1:],_instance.Tha,_instance.Tcb,_instance.Q_heattransfer_along)
    #print R_heat_list[1][1] # A 3D numpy array, contains heat resistance:af,fp,pw,wb, the former is R, the latter is relatives[1].
    R_mass_list = resistance_mass_transfer(T_test_list[:-1],T_test_list[1:],_instance.Tha,_instance.Tcb,_instance.Jv_flux_condensed_water_along)
    #print R_mass_list # A 3D numpy array, contains mass resistance:af[0],fp[1],pw[2],wb[3], the former[0] is R, the latter is relatives.
    #sum(R_heat_list[1])
    return R_mass_list


# In[31]:

def compute_heat_resistance(_instance):
    '''
    use func. resistance_heat_transfer to compute heat resistance along membrane.
    ------
    Returns
    -------
    Two 3D numpy array, contains heat resistance:af,fp,pw,wb, the former[0] is R, the latter[1] is relatives.
    The order of Rs is: Raf(air gap),Rfp(falling liquid water),Rpw(the cooling plate),Rwb(1/H, fluid heat transfer resistance in channel).
    '''
    T_test_list = np.array((_instance.Tha,_instance.Tf,_instance.Tfp,_instance.Tpc,_instance.Tcb))
    R_heat_list = resistance_heat_transfer(T_test_list[:-1],T_test_list[1:],_instance.Tha,_instance.Tcb,_instance.Q_heattransfer_along)
    #print R_heat_list[1][1] # A 3D numpy array, contains heat resistance:af,fp,pw,wb, the former is R, the latter is relatives[1].
    #R_mass_list = resistance_mass_transfer(T_test_list[:-1],T_test_list[1:],_instance.Tha,_instance.Tcb,_instance.Jv_flux_condensed_water_along)
    #print R_mass_list # A 3D numpy array, contains mass resistance:af[0],fp[1],pw[2],wb[3], the former[0] is R, the latter is relatives.
    #sum(R_heat_list[1])
    return R_heat_list


# In[32]:

def post_checking(check_instance):
    print "mh: %r" %(check_instance.mh)
    print "S_hot: %r g/kg" %(check_instance.S_hot)
    print "Thb along the membrane %r C" %check_instance.Thb
    print "Tha along the membrane %r C" %check_instance.Tha
    #print "Tma along the membrane %r C" %check_instance.Tma
    print "Tf along the membrane %r C" %check_instance.Tf
    print "Tcb along the membrane %r C" %check_instance.Tcb
    print "Jv along the length: %r (kg/(m2 hr))" %check_instance.Jv_flux_condensed_water_along
    print "Q_heat transfer along the length: %r (kJ/m2/hr)" %check_instance.Q_heattransfer_along
    print "delta_f along the length: %r (m)" %check_instance.delta_f_condensed_water_along


# In[33]:

def compute_R_heat(_instance):
    '''
    Using compute_heat_resistance(), outputs in IS unit. for GUI.
    Return absolute heat resistance.
    '''
    T_test_list = np.array((_instance.Tha,_instance.Tf,_instance.Tfp,_instance.Tpc,_instance.Tcb))
    R_heat_list = resistance_heat_transfer(T_test_list[:-1],T_test_list[1:],_instance.Tha,_instance.Tcb,_instance.Q_heattransfer_along)
    #print R_heat_list[1][1] # A 3D numpy array, contains heat resistance:af,fp,pw,wb, the former is R, the latter is relatives[1].
    #print R_mass_list # A 3D numpy array, contains mass resistance:af[0],fp[1],pw[2],wb[3], the former[0] is R, the latter is relatives.
    R_IS = R_heat_list[0]*3.6 # kJ-1 m2 K s 
    return R_IS


# In[34]:

def computeGOR(_instance):
    '''
    This func is for computing GOR. GOR = Jv*Hg/Qin = Jv/Qsteam
    --------
    Params
    -----
    _instance
    Returns
    --------
    GOR: demensionless number
    '''
    hg = CalculateEnthalpyEvaporation(0.5*(_instance.Tha + _instance.Tf)) # the enthalpy of flux water vapor in the air gap.
    Q_latent = hg * _instance.Jv_flux_condensed_water_along # kJ/kg *kg/m2/hr
    Q_latent_integrate = ((Q_latent[0]+Q_latent[-1])*0.5*_instance.dx + sum(Q_latent[1:-1])*_instance.dx)*_instance.width_effective
    Q_input = Cp_hot*_instance.mass_hot_inlet*(_instance.temperature_hot_inlet - _instance.Tcb[0]) # kJ/kg/K*kg/hr*K = kJ/hr
    return Q_latent_integrate/Q_input


# In[35]:

def compute_thermal_efficiency(_instance):
    '''
    This function calculates thermal efficiency for the model.
    ---------
    Params
    ------
    _instance: the instance of AG_D, from the instance getting Tairgap and Q.
    Returns
    -------
    thermal efficiency: Q_latent/Q_total
    '''
    #hg = CalculateEnthalpy(0.5*(_instance.Thb + _instance.Tf)) # the enthalpy(kJ/kg) of flux water vapor in the air gap.
    hg = CalculateEnthalpyEvaporation(_instance.Thb) # kJ/kg get the less enthalpy at higher temperature(Thb)
    Q_latent = hg * _instance.Jv_flux_condensed_water_along
    Q_total  = _instance.Q_heattransfer_along
    return Q_latent/Q_total   


# # 料液入口温度的影响

# ## Temperature of feeding water effects

# In[134]:

def make_comparasion_params(_compare_list_values,mass_flow,compare_label):
    '''
    This func. is for operating parameters comparasion.
    Cautions! Each time checking mhi,mci,thi,tci,airgap. 
    -----------------
    Params
    ------
    _compare_list: the list of values
    mass_flow: (kg/min) mass inlet
    compare_label: a string the name of the value
    Returns
    -------
    
    '''
    Jv_varies_ave = np.zeros(len(_compare_list_values))
    Jv_varies = np.empty_like(Jv_varies_ave,dtype=np.ndarray)
    EE_varies = np.empty_like(Jv_varies_ave,dtype=np.ndarray)
    EE_varies_ave = np.zeros(len(_compare_list_values))
    GOR_varies = np.zeros(len(_compare_list_values))
    R_heat_varies = np.zeros((4,len(_compare_list_values)))
    for test_i,compare_value in enumerate(_compare_list_values):
        print "The %s is: %.3f" %(compare_label,compare_value)
        compare_instance = exp_conditionB(_mhiB=mass_flow, _mciB=mass_flow, _thiB=compare_value, _tciB=20, _airgap=3.5e-3, Nx=20)
        #Num_grid = int(compare_value/0.05)
        #compare_instance = exp_conditionX(_vhi=.075,_vci=.075,_airgap=4e-3,_length=compare_value,Nx=Num_grid)
        Jv_varies_ave[test_i] = compare_instance.Jv_flux_average #Jv (average along membrane) for each instance
        Jv_varies[test_i] = compare_instance.Jv_flux_condensed_water_along # Jv along the membrane
        EE_varies[test_i] = compute_thermal_efficiency(compare_instance)
        #EE_varies_ave[test_i] = EE_varies
        GOR_varies[test_i] = computeGOR(compare_instance)
        R_heat_temp = compute_heat_resistance(compare_instance)
        R_heat_varies[0,test_i] = R_heat_temp[0][0][-1]
        R_heat_varies[1,test_i] = R_heat_temp[0][1][-1]
        R_heat_varies[2,test_i] = R_heat_temp[0][2][-1]
        R_heat_varies[3,test_i] = R_heat_temp[0][3][-1]
        print
        print 
    print Jv_varies_ave
    print R_heat_varies
    #print EE_varies
    print "Attention! Each time, check: velocity_in, air_gap, length of the model, Nx!"
    print GOR_varies
    return Jv_varies_ave,R_heat_varies,EE_varies,GOR_varies


# Comparasion on T_hot
#T_hot_Nvalues = np.array([50,60,70,80]) # m/s
#Jv_varies_Thot_ave,R_heat_varies_Thot,EE_varies_Thot,GOR_varies_Thot = make_comparasion_params(T_hot_Nvalues,mass_in,'Temperature inlet(C)')


# In[135]:

def multi_mass_Jv_T(mass_list,T_hot_list):
    '''
    '''
    Jv_mass_T = np.zeros((len(mass_list),len(T_hot_list)))
    for test_i,mass in enumerate(mass_list):
        print 
        print 
        print "The mass flow is: %.5f LPM" %mass
        Jv_mass_T[test_i],R_mass,TE_mass,GOR_mass = make_comparasion_params(T_hot_list,mass,'Temperature inlet(C)')
    print Jv_mass_T
    return Jv_mass_T
mass_list_values = np.linspace(2.5,12,5)
T_hot_Nvalues = np.array([50,60,70,80]) # m/s
Jv_mass_Tin = multi_mass_Jv_T(mass_list_values,T_hot_Nvalues)


# In[143]:

mass_list_labels = ['2.5L/min','4.9L/min','7.25L/min','9.63L/min','12L/min']
plot_flux_vs_X_mass('Flux vs. Temperature hot inlet and Mass flow','Flux(kg/m/hr)',mass_list_labels,                    'Temperature feeding inlet(C)',T_hot_Nvalues,Jv_mass_Tin,' x_limits',' y_limits')


# ## Temperature of ooling water effects

# In[144]:

def make_comparasion_params(_compare_list_values,mass_flow,compare_label):
    '''
    This func. is for operating parameters comparasion.
    Cautions! Each time checking mhi,mci,thi,tci,airgap. 
    -----------------
    Params
    ------
    _compare_list: the list of values
    mass_flow: (kg/min) mass inlet
    compare_label: a string the name of the value
    Returns
    -------
    
    '''
    Jv_varies_ave = np.zeros(len(_compare_list_values))
    Jv_varies = np.empty_like(Jv_varies_ave,dtype=np.ndarray)
    EE_varies = np.empty_like(Jv_varies_ave,dtype=np.ndarray)
    EE_varies_ave = np.zeros(len(_compare_list_values))
    GOR_varies = np.zeros(len(_compare_list_values))
    R_heat_varies = np.zeros((4,len(_compare_list_values)))
    for test_i,compare_value in enumerate(_compare_list_values):
        print "The %s is: %.3f" %(compare_label,compare_value)
        compare_instance = exp_conditionB(_mhiB=mass_flow, _mciB=mass_flow, _thiB=80, _tciB=compare_value, _airgap=3.5e-3, Nx=20)
        #Num_grid = int(compare_value/0.05)
        #compare_instance = exp_conditionX(_vhi=.075,_vci=.075,_airgap=4e-3,_length=compare_value,Nx=Num_grid)
        Jv_varies_ave[test_i] = compare_instance.Jv_flux_average #Jv (average along membrane) for each instance
        Jv_varies[test_i] = compare_instance.Jv_flux_condensed_water_along # Jv along the membrane
        EE_varies[test_i] = compute_thermal_efficiency(compare_instance)
        #EE_varies_ave[test_i] = EE_varies
        GOR_varies[test_i] = computeGOR(compare_instance)
        R_heat_temp = compute_heat_resistance(compare_instance)
        R_heat_varies[0,test_i] = R_heat_temp[0][0][-1]
        R_heat_varies[1,test_i] = R_heat_temp[0][1][-1]
        R_heat_varies[2,test_i] = R_heat_temp[0][2][-1]
        R_heat_varies[3,test_i] = R_heat_temp[0][3][-1]
        print
        print 
    print Jv_varies_ave
    print R_heat_varies
    #print EE_varies
    print "Attention! Each time, check: velocity_in, air_gap, length of the model, Nx!"
    print GOR_varies
    return Jv_varies_ave
def multi_mass_Jv_T(mass_list,T_hot_list):
    '''
    '''
    Jv_mass_T = np.zeros((len(mass_list),len(T_hot_list)))
    for test_i,mass in enumerate(mass_list):
        print 
        print 
        print "The mass flow is: %.5f LPM" %mass
        Jv_mass_T[test_i] = make_comparasion_params(T_hot_list,mass,'Temperature inlet(C)')
    print Jv_mass_T
    return Jv_mass_T
mass_list_values = np.linspace(5,15,5)
T_cold_Nvalues = np.array([20,30,40,50]) # m/s
Jv_mass_Tin = multi_mass_Jv_T(mass_list_values,T_cold_Nvalues)


# In[166]:

mass_list_labels = ['5.0L/min','7.5L/min','10.0L/min','12.5L/min','15.0L/min']
plot_flux_vs_X('Flux vs. Temperature cooling inlet and Mass flow','Flux(kg/m/hr)',mass_list_labels,               'Temperature cooling inlet(C)',T_cold_Nvalues,Jv_mass_Tin,' ','')


# In[50]:

plot_flux_vs_X('J v vs. Temperature_hot, when Qh=5.5L/M,airgap=3.5e-3m,Tc=20C','Flux (kg/m2/hr)','','Temperature Hot Inlet (C)',              T_hot_Nvalues,Jv_varies_Thot_ave,'no','')


# In[42]:

plot_flux_vs_X('GOR vs. T_cooling, when mass_hot=80LPM,mass_cooling=80LPM,len=1m,airgap=4mm','GOR','','feeding Temperature (C)',              T_hot_Nvalues,GOR_varies_Thot,'no','')


# In[146]:

plot_flux_vs_X('Evaporation Efficiency vs. Tin, when mass_hot=80LPM,mass_cooling=80LPM,len=1m,airgap=4mm','E E','','feeding Temperature (C)',              T_hot_Nvalues,EE_varies_Thot,'no','')


# # 料液入口速度影响

# In[36]:

# Comparasion on velocity
velocity_Nvalues = np.array([.025,.05,.075,0.1]) # m/s
Jv_varies_velocity_ave = np.zeros(len(velocity_Nvalues))
Jv_varies_velocity = np.empty_like(Jv_varies_velocity_ave,dtype=np.ndarray)
GOR_varies_velocity = np.zeros(len(velocity_Nvalues))
R_heat_r_velocity = np.zeros((4,len(velocity_Nvalues)))
for test_i,velocity_inlet in enumerate(velocity_Nvalues):
    print "The inlet velocity is: %.3f m/s" %velocity_inlet
    compare_velocity = exp_conditionX(_vhi=velocity_inlet,_vci=velocity_inlet,_airgap=4e-3,_length=1.,Nx=20)
    Jv_varies_velocity_ave[test_i] = compare_velocity.Jv_flux_average #Jv (average along membrane) for each instance
    Jv_varies_velocity[test_i] = compare_velocity.Jv_flux_condensed_water_along # Jv along the membrane
    GOR_varies_velocity[test_i] = computeGOR(compare_velocity)
    R_heat_velocity_temp = compute_R_heat(compare_velocity)
    R_heat_r_velocity[0,test_i] = R_heat_velocity_temp[0][-1]
    R_heat_r_velocity[1,test_i] = R_heat_velocity_temp[1][-1]
    R_heat_r_velocity[2,test_i] = R_heat_velocity_temp[2][-1]
    R_heat_r_velocity[3,test_i] = R_heat_velocity_temp[3][-1]
    print
    print 
print Jv_varies_velocity_ave
print R_heat_r_velocity
print GOR_varies_velocity
# pay attention: 0.5m/s Re=1500<2100 laminar flow.


# In[164]:

R_labels = ["Ra","Rf","Rp","Rc"]
plot_flux_vs_X('Heat resistance vs. Velocity inlet','R (kJ-1 m2 K s)',R_labels,'Velocity Inlet (m/s)',              velocity_Nvalues,R_heat_r_velocity,[0.025,0.1],[0,.007])


# In[38]:

plot_flux_vs_X('J v vs. V_hot_inlet, when V_cooling=0.05m/s,airgap=4e-3m,len=1m','Flux (kg/m2/hr)','','Velocity Hot Inlet (m/s)',              velocity_Nvalues,Jv_varies_velocity_ave,'no','')


# In[39]:

plot_flux_vs_X('GOR vs. Velocity inlet, when airgap=4e-3m,len=1m','GOR','','Velocity Hot Inlet (m/s)',              velocity_Nvalues,GOR_varies_velocity,'no','')


# In[40]:

V_labels = ["0.025m/s","0.050m/s","0.075m/s","0.100m/s"]
plot_flux_vs_X('Flux vs. Velocity inlet','Flux (kg/m/hr)',V_labels,'x along the membrane(m)',              compare_velocity.x,Jv_varies_velocity,'[0.025,.2]','[0,.002]')


# # 模型长度影响

# In[42]:

def make_comparasion_params(_compare_list_values,compare_label):
    '''
    This func. is for operating parameters comparasion.
    Cautions! Each time checking mhi,mci,thi,tci,airgap. 
    -----------------
    Params
    ------
    _compare_list: the list of values
    compare_label: a string the name of the value
    Returns
    -------
    
    '''
    Jv_varies_ave = np.zeros(len(_compare_list_values))
    Jv_varies = np.empty_like(Jv_varies_ave,dtype=np.ndarray)
    EE_varies = np.empty_like(Jv_varies_ave,dtype=np.ndarray)
    EE_varies_ave = np.zeros(len(_compare_list_values))
    GOR_varies = np.zeros(len(_compare_list_values))
    R_heat_varies = np.zeros((4,len(_compare_list_values)))
    T_Cout_len = np.zeros(len(_compare_list_values))
    T_out_len = np.zeros(len(_compare_list_values))
    for test_i,compare_value in enumerate(_compare_list_values):
        print "The %s is: %.3f" %(compare_label,compare_value)
        #compare_instance = exp_conditionB(_mhiB=5.5, _mciB=5.5, _thiB=compare_value, _tciB=20, _airgap=3.5e-3, Nx=20)
        Num_grid = int(compare_value/0.05)
        compare_instance = exp_conditionX(_vhi=.051,_vci=.0675,_airgap=4e-3,_length=compare_value,Nx=Num_grid)
        Jv_varies_ave[test_i] = compare_instance.Jv_flux_average #Jv (average along membrane) for each instance
        Jv_varies[test_i] = compare_instance.Jv_flux_condensed_water_along # Jv along the membrane
        EE_varies[test_i] = compute_thermal_efficiency(compare_instance)
        #EE_varies_ave[test_i] = EE_varies
        GOR_varies[test_i] = computeGOR(compare_instance)
        T_out_len[test_i] = compare_instance.Thb[-1]
        T_Cout_len[test_i] = compare_instance.Tcb[0]
        R_heat_temp = compute_R_heat(compare_instance)
        R_heat_varies[0,test_i] = R_heat_temp[0][-1]
        R_heat_varies[1,test_i] = R_heat_temp[1][-1]
        R_heat_varies[2,test_i] = R_heat_temp[2][-1]
        R_heat_varies[3,test_i] = R_heat_temp[3][-1]
        print
        print 
    print Jv_varies_ave
    print R_heat_varies
    #print EE_varies
    print "Attention! Each time, check: velocity_in, air_gap, length of the model, Nx!"
    print GOR_varies
    return Jv_varies_ave,R_heat_varies,EE_varies,GOR_varies,T_out_len,T_Cout_len

# Comparasion on length of the model.
length_Nvalues = np.array([0.2,0.5,1.,2.]) # m
Jv_varies_len,R_heat_varies_len,EE_varies_len,GOR_varies_len,T_Hout,T_Cout = make_comparasion_params(length_Nvalues,                                                                                                                      'Length (m)')


# In[55]:

R_labels = ["Ra","Rf","Rp","Rc"]
plot_flux_vs_X('Heat resistance at cooling outlet vs. Height of the model','R heat (kJ-1 m2 K s)',               R_labels,'Heigth (m)',length_Nvalues,R_heat_varies_len,'no','')


# In[47]:

plot_flux_vs_X('Flux vs. Length of model','Flux (kg/m2/hr)','','Length of model (m)',              length_Nvalues,Jv_varies_len,[0.2,2.],[8,20])


# In[44]:

plot_flux_vs_X('Feeding Temperature outlet vs. Length, when V_hot=.075m/s,V_cooling=0.075m/s,airgap=4e-3m','Feeding out Temperature (C)',               '','Length of model (m)',length_Nvalues,T_Hout,'no','')


# In[58]:

plot_flux_vs_X('Feeding Temperature outlet vs. Length, when V_hot=.075m/s,V_cooling=0.075m/s,airgap=4e-3m','Cooling out Temperature (C)',               '','Length of model (m)',length_Nvalues,T_Cout,'no','')


# In[59]:

plot_flux_vs_X('GOR vs. Length, when V_hot=.075m/s,V_cooling=0.075m/s,airgap=4e-3m','GOR','','Length of model (m)',              length_Nvalues,GOR_varies_len,'no','')


# # 空气隙宽度影响

# In[41]:

# Comparasion on airgap of the model
airgap_Nvalues = np.array([2.0e-3,2.5e-3,3e-3,3.5e-3,4e-3]) # m
Jv_varies_airgap_ave = np.zeros(len(airgap_Nvalues))
Jv_varies_airgap = np.empty_like(Jv_varies_airgap_ave,dtype=np.ndarray)
#Q_varies_airgap = np.zeros(len(airgap_Nvalues))
R_heat_airgap = np.zeros((4,len(airgap_Nvalues)))
GOR_varies_airgap = np.zeros(len(airgap_Nvalues))
for test_i,airgap_of_model in enumerate(airgap_Nvalues):
    print "The airgap of the model is: %.5f m" %airgap_of_model
    compare_airgap = exp_conditionX(_vhi=.051,_vci=.067,_airgap=airgap_of_model,_length=1.,Nx=20) #6LPM
    Jv_varies_airgap_ave[test_i] = compare_airgap.Jv_flux_average #Jv (average along membrane) for each instance
    Jv_varies_airgap[test_i] = compare_airgap.Jv_flux_condensed_water_along # Jv along the memb
    R_heat_temp = compute_R_heat(compare_airgap)
    R_heat_airgap[0,test_i] = R_heat_temp[0][-1]
    R_heat_airgap[1,test_i] = R_heat_temp[1][-1]
    R_heat_airgap[2,test_i] = R_heat_temp[2][-1]
    R_heat_airgap[3,test_i] = R_heat_temp[3][-1]
    GOR_varies_airgap[test_i] = computeGOR(compare_airgap)
    print
    print
print Jv_varies_airgap_ave
print R_heat_airgap


# In[48]:

airgap_labels = ["2.0mm","2.5mm","3.0mm","3.5mm","4.0mm"]
plot_flux_vs_X('Flux vs. Air gap distance','Flux (kg/m/hr)',airgap_labels,'x along membrane(m)',              compare_airgap.x,Jv_varies_airgap,'[0.025,.2]','[0,.002]')


# In[47]:

R_labels = ["Ra","Rf","Rp","Rc"]
plot_flux_vs_X('Heat resistance vs. Air gap distance','R heat (kJ-1 m2 K s)',               R_labels,'air gap distance (m)',airgap_Nvalues,R_heat_airgap,'no','')


# In[49]:

plot_flux_vs_X('GOR vs. air gap distance, when velocity_in=0.075m/s,len=1m,Th=80C,Tc=20C','GOR','','air gap distance (m)',              airgap_Nvalues,GOR_varies_airgap,'[0.002,0.004]','[0.25,0.6]')


# In[51]:

plot_flux_vs_X('J v vs. Airgap, when Velocity_in=.051m/s,len=1m,Th=80C,Tc=20C','Flux (kg/m2/hr)','','Air gap distance (m)',              airgap_Nvalues,Jv_varies_airgap_ave,'[0.002,0.004]','[15,23]')


# ## For single example test

# In[41]:

# for using PE as cooling plate.
test_v = exp_conditionX(_vhi=.5,_vci=.5,_airgap=4e-3,_length=1.,Nx=20)


# In[127]:

T_list_labels = ["Tha","Taf","Tfp","Tpc","Tcb"]
T_list_values = [test_v.Tha,test_v.Tf,test_v.Tfp,test_v.Tpc,test_v.Tcb]
plot_muliti_along("Temperature along Model",T_list_labels,test_v.x,                    T_list_values,'Temperature(C)',[10,85])


# In[130]:

R_labels = ["Ra","Rf","Rp","Rc"]
R_heat_IS = compute_R_heat(test_v)
plot_flux_vs_X('Heat resistance along Model','R heat (kJ-1 m2 K s)',               R_labels,'x (m)',test_v.x,R_heat_IS,'no','')


# In[131]:

plot_along_membrane(plot_title="Test on Jv",plot_ylabel="Jv_along(kg/m2 hr)",x_values=test_v.x,                    y_values=test_v.Jv_flux_condensed_water_along ,y_limits="no")


# In[132]:

plot_along_membrane(plot_title="Test on delta_f",plot_ylabel="deltaf_along(m)",x_values=test_v.x,                    y_values=test_v.delta_f_condensed_water_along ,y_limits=[0.,1e-4])


# In[133]:

plot_along_membrane(plot_title="Test on Q",plot_ylabel="Q(kJ/m2 hr)",x_values=test_v.x,                    y_values=test_v.Q_heattransfer_along ,y_limits="no")

